#include "AES.h"
namespace screw {
namespace algo {
namespace AES {
/*
// XTIME 计算
template <screw::uint8 x>
DECL_STATIC_CONSTEXPR uint8 XTIME = (x << 1) ^ (((x >> 7) & 1) * 0x1b);
template <screw::uint8 x>
DECL_STATIC_CONSTEXPR uint8 XTIME2 = XTIME<XTIME<x>>;
template <screw::uint8 x>
DECL_STATIC_CONSTEXPR uint8 XTIME3 = XTIME<XTIME2<x>>;
template <screw::uint8 x>
DECL_STATIC_CONSTEXPR uint8 XTIME4 = XTIME<XTIME3<x>>;
// MUL 计算
template <screw::uint8 x, screw::uint8 y>
DECL_STATIC_CONSTEXPR uint8 MUL = ((y & 1) * x) ^             //
                                  ((y >> 1 & 1) * XTIME<x>)^  //
                                  ((y >> 2 & 1) * XTIME2<x>)^ //
                                  ((y >> 3 & 1) * XTIME3<x>)^ //
                                  ((y >> 4 & 1) * XTIME4<x>);
*/
// MUL<0, 0x09> ~ MUL<0xff, 0x09>
DECL_STATIC_CONSTEXPR uint8 MUL_9[256] = {0x00, 0x09, 0x12, 0x1B, 0x24, 0x2D, 0x36, 0x3F, 0x48, 0x41, 0x5A, 0x53, 0x6C, 0x65, 0x7E, 0x77, 0x90, 0x99, 0x82, 0x8B, 0xB4, 0xBD, 0xA6, 0xAF, 0xD8, 0xD1, 0xCA, 0xC3, 0xFC, 0xF5, 0xEE, 0xE7, 0x3B, 0x32, 0x29, 0x20, 0x1F, 0x16, 0x0D, 0x04, 0x73, 0x7A, 0x61, 0x68, 0x57, 0x5E, 0x45, 0x4C, 0xAB, 0xA2, 0xB9, 0xB0, 0x8F, 0x86, 0x9D, 0x94, 0xE3, 0xEA, 0xF1, 0xF8, 0xC7, 0xCE, 0xD5, 0xDC, 0x76, 0x7F, 0x64, 0x6D, 0x52, 0x5B, 0x40, 0x49, 0x3E, 0x37, 0x2C, 0x25, 0x1A, 0x13, 0x08, 0x01, 0xE6, 0xEF, 0xF4, 0xFD, 0xC2, 0xCB, 0xD0, 0xD9, 0xAE, 0xA7, 0xBC, 0xB5, 0x8A, 0x83, 0x98, 0x91, 0x4D, 0x44, 0x5F, 0x56, 0x69, 0x60, 0x7B, 0x72, 0x05, 0x0C, 0x17, 0x1E, 0x21, 0x28, 0x33, 0x3A, 0xDD, 0xD4, 0xCF, 0xC6, 0xF9, 0xF0, 0xEB, 0xE2, 0x95, 0x9C, 0x87, 0x8E, 0xB1, 0xB8, 0xA3, 0xAA, 0xEC, 0xE5, 0xFE, 0xF7, 0xC8, 0xC1, 0xDA, 0xD3, 0xA4, 0xAD, 0xB6, 0xBF, 0x80, 0x89, 0x92, 0x9B, 0x7C, 0x75, 0x6E, 0x67, 0x58, 0x51, 0x4A, 0x43, 0x34, 0x3D, 0x26, 0x2F, 0x10, 0x19, 0x02, 0x0B, 0xD7, 0xDE, 0xC5, 0xCC, 0xF3, 0xFA, 0xE1, 0xE8, 0x9F, 0x96, 0x8D, 0x84, 0xBB, 0xB2, 0xA9, 0xA0, 0x47, 0x4E, 0x55, 0x5C, 0x63, 0x6A, 0x71, 0x78, 0x0F, 0x06, 0x1D, 0x14, 0x2B, 0x22, 0x39, 0x30, 0x9A, 0x93, 0x88, 0x81, 0xBE, 0xB7, 0xAC, 0xA5, 0xD2, 0xDB, 0xC0, 0xC9, 0xF6, 0xFF, 0xE4, 0xED, 0x0A, 0x03, 0x18, 0x11, 0x2E, 0x27, 0x3C, 0x35, 0x42, 0x4B, 0x50, 0x59, 0x66, 0x6F, 0x74, 0x7D, 0xA1, 0xA8, 0xB3, 0xBA, 0x85, 0x8C, 0x97, 0x9E, 0xE9, 0xE0, 0xFB, 0xF2, 0xCD, 0xC4, 0xDF, 0xD6, 0x31, 0x38, 0x23, 0x2A, 0x15, 0x1C, 0x07, 0x0E, 0x79, 0x70, 0x6B, 0x62, 0x5D, 0x54, 0x4F, 0x46};

// MUL<0, 0x0b> ~ MUL<0xff, 0x0b>
DECL_STATIC_CONSTEXPR uint8 MUL_B[256] = {0x00, 0x0B, 0x16, 0x1D, 0x2C, 0x27, 0x3A, 0x31, 0x58, 0x53, 0x4E, 0x45, 0x74, 0x7F, 0x62, 0x69, 0xB0, 0xBB, 0xA6, 0xAD, 0x9C, 0x97, 0x8A, 0x81, 0xE8, 0xE3, 0xFE, 0xF5, 0xC4, 0xCF, 0xD2, 0xD9, 0x7B, 0x70, 0x6D, 0x66, 0x57, 0x5C, 0x41, 0x4A, 0x23, 0x28, 0x35, 0x3E, 0x0F, 0x04, 0x19, 0x12, 0xCB, 0xC0, 0xDD, 0xD6, 0xE7, 0xEC, 0xF1, 0xFA, 0x93, 0x98, 0x85, 0x8E, 0xBF, 0xB4, 0xA9, 0xA2, 0xF6, 0xFD, 0xE0, 0xEB, 0xDA, 0xD1, 0xCC, 0xC7, 0xAE, 0xA5, 0xB8, 0xB3, 0x82, 0x89, 0x94, 0x9F, 0x46, 0x4D, 0x50, 0x5B, 0x6A, 0x61, 0x7C, 0x77, 0x1E, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2F, 0x8D, 0x86, 0x9B, 0x90, 0xA1, 0xAA, 0xB7, 0xBC, 0xD5, 0xDE, 0xC3, 0xC8, 0xF9, 0xF2, 0xEF, 0xE4, 0x3D, 0x36, 0x2B, 0x20, 0x11, 0x1A, 0x07, 0x0C, 0x65, 0x6E, 0x73, 0x78, 0x49, 0x42, 0x5F, 0x54, 0xF7, 0xFC, 0xE1, 0xEA, 0xDB, 0xD0, 0xCD, 0xC6, 0xAF, 0xA4, 0xB9, 0xB2, 0x83, 0x88, 0x95, 0x9E, 0x47, 0x4C, 0x51, 0x5A, 0x6B, 0x60, 0x7D, 0x76, 0x1F, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2E, 0x8C, 0x87, 0x9A, 0x91, 0xA0, 0xAB, 0xB6, 0xBD, 0xD4, 0xDF, 0xC2, 0xC9, 0xF8, 0xF3, 0xEE, 0xE5, 0x3C, 0x37, 0x2A, 0x21, 0x10, 0x1B, 0x06, 0x0D, 0x64, 0x6F, 0x72, 0x79, 0x48, 0x43, 0x5E, 0x55, 0x01, 0x0A, 0x17, 0x1C, 0x2D, 0x26, 0x3B, 0x30, 0x59, 0x52, 0x4F, 0x44, 0x75, 0x7E, 0x63, 0x68, 0xB1, 0xBA, 0xA7, 0xAC, 0x9D, 0x96, 0x8B, 0x80, 0xE9, 0xE2, 0xFF, 0xF4, 0xC5, 0xCE, 0xD3, 0xD8, 0x7A, 0x71, 0x6C, 0x67, 0x56, 0x5D, 0x40, 0x4B, 0x22, 0x29, 0x34, 0x3F, 0x0E, 0x05, 0x18, 0x13, 0xCA, 0xC1, 0xDC, 0xD7, 0xE6, 0xED, 0xF0, 0xFB, 0x92, 0x99, 0x84, 0x8F, 0xBE, 0xB5, 0xA8, 0xA3};

// MUL<0, 0x0d> ~ MUL<0xff, 0x0d>
DECL_STATIC_CONSTEXPR uint8 MUL_D[256] = {0x00, 0x0D, 0x1A, 0x17, 0x34, 0x39, 0x2E, 0x23, 0x68, 0x65, 0x72, 0x7F, 0x5C, 0x51, 0x46, 0x4B, 0xD0, 0xDD, 0xCA, 0xC7, 0xE4, 0xE9, 0xFE, 0xF3, 0xB8, 0xB5, 0xA2, 0xAF, 0x8C, 0x81, 0x96, 0x9B, 0xBB, 0xB6, 0xA1, 0xAC, 0x8F, 0x82, 0x95, 0x98, 0xD3, 0xDE, 0xC9, 0xC4, 0xE7, 0xEA, 0xFD, 0xF0, 0x6B, 0x66, 0x71, 0x7C, 0x5F, 0x52, 0x45, 0x48, 0x03, 0x0E, 0x19, 0x14, 0x37, 0x3A, 0x2D, 0x20, 0x6D, 0x60, 0x77, 0x7A, 0x59, 0x54, 0x43, 0x4E, 0x05, 0x08, 0x1F, 0x12, 0x31, 0x3C, 0x2B, 0x26, 0xBD, 0xB0, 0xA7, 0xAA, 0x89, 0x84, 0x93, 0x9E, 0xD5, 0xD8, 0xCF, 0xC2, 0xE1, 0xEC, 0xFB, 0xF6, 0xD6, 0xDB, 0xCC, 0xC1, 0xE2, 0xEF, 0xF8, 0xF5, 0xBE, 0xB3, 0xA4, 0xA9, 0x8A, 0x87, 0x90, 0x9D, 0x06, 0x0B, 0x1C, 0x11, 0x32, 0x3F, 0x28, 0x25, 0x6E, 0x63, 0x74, 0x79, 0x5A, 0x57, 0x40, 0x4D, 0xDA, 0xD7, 0xC0, 0xCD, 0xEE, 0xE3, 0xF4, 0xF9, 0xB2, 0xBF, 0xA8, 0xA5, 0x86, 0x8B, 0x9C, 0x91, 0x0A, 0x07, 0x10, 0x1D, 0x3E, 0x33, 0x24, 0x29, 0x62, 0x6F, 0x78, 0x75, 0x56, 0x5B, 0x4C, 0x41, 0x61, 0x6C, 0x7B, 0x76, 0x55, 0x58, 0x4F, 0x42, 0x09, 0x04, 0x13, 0x1E, 0x3D, 0x30, 0x27, 0x2A, 0xB1, 0xBC, 0xAB, 0xA6, 0x85, 0x88, 0x9F, 0x92, 0xD9, 0xD4, 0xC3, 0xCE, 0xED, 0xE0, 0xF7, 0xFA, 0xB7, 0xBA, 0xAD, 0xA0, 0x83, 0x8E, 0x99, 0x94, 0xDF, 0xD2, 0xC5, 0xC8, 0xEB, 0xE6, 0xF1, 0xFC, 0x67, 0x6A, 0x7D, 0x70, 0x53, 0x5E, 0x49, 0x44, 0x0F, 0x02, 0x15, 0x18, 0x3B, 0x36, 0x21, 0x2C, 0x0C, 0x01, 0x16, 0x1B, 0x38, 0x35, 0x22, 0x2F, 0x64, 0x69, 0x7E, 0x73, 0x50, 0x5D, 0x4A, 0x47, 0xDC, 0xD1, 0xC6, 0xCB, 0xE8, 0xE5, 0xF2, 0xFF, 0xB4, 0xB9, 0xAE, 0xA3, 0x80, 0x8D, 0x9A, 0x97};

// MUL<0, 0x0e> ~ MUL<0xff, 0x0e>
DECL_STATIC_CONSTEXPR uint8 MUL_E[256] = {0x00, 0x0E, 0x1C, 0x12, 0x38, 0x36, 0x24, 0x2A, 0x70, 0x7E, 0x6C, 0x62, 0x48, 0x46, 0x54, 0x5A, 0xE0, 0xEE, 0xFC, 0xF2, 0xD8, 0xD6, 0xC4, 0xCA, 0x90, 0x9E, 0x8C, 0x82, 0xA8, 0xA6, 0xB4, 0xBA, 0xDB, 0xD5, 0xC7, 0xC9, 0xE3, 0xED, 0xFF, 0xF1, 0xAB, 0xA5, 0xB7, 0xB9, 0x93, 0x9D, 0x8F, 0x81, 0x3B, 0x35, 0x27, 0x29, 0x03, 0x0D, 0x1F, 0x11, 0x4B, 0x45, 0x57, 0x59, 0x73, 0x7D, 0x6F, 0x61, 0xAD, 0xA3, 0xB1, 0xBF, 0x95, 0x9B, 0x89, 0x87, 0xDD, 0xD3, 0xC1, 0xCF, 0xE5, 0xEB, 0xF9, 0xF7, 0x4D, 0x43, 0x51, 0x5F, 0x75, 0x7B, 0x69, 0x67, 0x3D, 0x33, 0x21, 0x2F, 0x05, 0x0B, 0x19, 0x17, 0x76, 0x78, 0x6A, 0x64, 0x4E, 0x40, 0x52, 0x5C, 0x06, 0x08, 0x1A, 0x14, 0x3E, 0x30, 0x22, 0x2C, 0x96, 0x98, 0x8A, 0x84, 0xAE, 0xA0, 0xB2, 0xBC, 0xE6, 0xE8, 0xFA, 0xF4, 0xDE, 0xD0, 0xC2, 0xCC, 0x41, 0x4F, 0x5D, 0x53, 0x79, 0x77, 0x65, 0x6B, 0x31, 0x3F, 0x2D, 0x23, 0x09, 0x07, 0x15, 0x1B, 0xA1, 0xAF, 0xBD, 0xB3, 0x99, 0x97, 0x85, 0x8B, 0xD1, 0xDF, 0xCD, 0xC3, 0xE9, 0xE7, 0xF5, 0xFB, 0x9A, 0x94, 0x86, 0x88, 0xA2, 0xAC, 0xBE, 0xB0, 0xEA, 0xE4, 0xF6, 0xF8, 0xD2, 0xDC, 0xCE, 0xC0, 0x7A, 0x74, 0x66, 0x68, 0x42, 0x4C, 0x5E, 0x50, 0x0A, 0x04, 0x16, 0x18, 0x32, 0x3C, 0x2E, 0x20, 0xEC, 0xE2, 0xF0, 0xFE, 0xD4, 0xDA, 0xC8, 0xC6, 0x9C, 0x92, 0x80, 0x8E, 0xA4, 0xAA, 0xB8, 0xB6, 0x0C, 0x02, 0x10, 0x1E, 0x34, 0x3A, 0x28, 0x26, 0x7C, 0x72, 0x60, 0x6E, 0x44, 0x4A, 0x58, 0x56, 0x37, 0x39, 0x2B, 0x25, 0x0F, 0x01, 0x13, 0x1D, 0x47, 0x49, 0x5B, 0x55, 0x7F, 0x71, 0x63, 0x6D, 0xD7, 0xD9, 0xCB, 0xC5, 0xEF, 0xE1, 0xF3, 0xFD, 0xA7, 0xA9, 0xBB, 0xB5, 0x9F, 0x91, 0x83, 0x8D};

// XTIME<0> ~ XTIME<0xff>
DECL_STATIC_CONSTEXPR uint8 XTIME[256] = {0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E, 0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE, 0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFE, 0x1B, 0x19, 0x1F, 0x1D, 0x13, 0x11, 0x17, 0x15, 0x0B, 0x09, 0x0F, 0x0D, 0x03, 0x01, 0x07, 0x05, 0x3B, 0x39, 0x3F, 0x3D, 0x33, 0x31, 0x37, 0x35, 0x2B, 0x29, 0x2F, 0x2D, 0x23, 0x21, 0x27, 0x25, 0x5B, 0x59, 0x5F, 0x5D, 0x53, 0x51, 0x57, 0x55, 0x4B, 0x49, 0x4F, 0x4D, 0x43, 0x41, 0x47, 0x45, 0x7B, 0x79, 0x7F, 0x7D, 0x73, 0x71, 0x77, 0x75, 0x6B, 0x69, 0x6F, 0x6D, 0x63, 0x61, 0x67, 0x65, 0x9B, 0x99, 0x9F, 0x9D, 0x93, 0x91, 0x97, 0x95, 0x8B, 0x89, 0x8F, 0x8D, 0x83, 0x81, 0x87, 0x85, 0xBB, 0xB9, 0xBF, 0xBD, 0xB3, 0xB1, 0xB7, 0xB5, 0xAB, 0xA9, 0xAF, 0xAD, 0xA3, 0xA1, 0xA7, 0xA5, 0xDB, 0xD9, 0xDF, 0xDD, 0xD3, 0xD1, 0xD7, 0xD5, 0xCB, 0xC9, 0xCF, 0xCD, 0xC3, 0xC1, 0xC7, 0xC5, 0xFB, 0xF9, 0xFF, 0xFD, 0xF3, 0xF1, 0xF7, 0xF5, 0xEB, 0xE9, 0xEF, 0xED, 0xE3, 0xE1, 0xE7, 0xE5};

// 轮系数
DECL_STATIC_CONSTEXPR uint8 RCON[11] = {0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36};

// S盒
DECL_STATIC_CONSTEXPR uint8 SBOX[256] = {0xCE, 0x3F, 0x54, 0x81, 0x0E, 0xF7, 0x0F, 0x7D, 0x5B, 0xCF, 0x94, 0xD3, 0xF0, 0x31, 0x09, 0xC9, 0x04, 0x08, 0x12, 0x67, 0x97, 0xBF, 0x7C, 0xA7, 0xAF, 0x68, 0x1F, 0xE7, 0xBD, 0x43, 0x5C, 0x2D, 0xDB, 0xE1, 0x9C, 0xAB, 0xFB, 0x4E, 0x87, 0x49, 0xCB, 0xEC, 0x99, 0x1A, 0xA3, 0x1E, 0x6F, 0x16, 0x6E, 0x64, 0x50, 0x52, 0xD9, 0x9A, 0xBC, 0x5E, 0x8C, 0xDC, 0xC2, 0xFA, 0x22, 0x5D, 0x2E, 0xEA, 0xFE, 0x25, 0x8E, 0x8A, 0xE5, 0xB0, 0x5A, 0xE9, 0x91, 0x80, 0x40, 0x18, 0x19, 0xEF, 0xB1, 0x5F, 0xAA, 0x73, 0xFD, 0xBE, 0xDD, 0x98, 0x17, 0x46, 0xB7, 0x11, 0x45, 0x86, 0x3A, 0x82, 0x07, 0x35, 0x3D, 0x78, 0x9E, 0x15, 0x26, 0x8D, 0xD1, 0xF2, 0xD5, 0xBA, 0xA1, 0x39, 0xE3, 0x32, 0x30, 0x29, 0xDF, 0x20, 0xC6, 0x41, 0xB3, 0x9D, 0x59, 0xED, 0x1D, 0x28, 0xF5, 0x93, 0xB6, 0x05, 0x65, 0x7A, 0x85, 0x96, 0x72, 0xAC, 0xA4, 0xD0, 0xA9, 0xC3, 0x9B, 0xB8, 0x88, 0xFF, 0x2A, 0x61, 0x01, 0xA8, 0x53, 0xEE, 0x4F, 0xA0, 0xDE, 0x37, 0x36, 0xC4, 0x7F, 0xF9, 0x13, 0xE2, 0x23, 0x2F, 0xB2, 0x8F, 0xC1, 0x00, 0x3E, 0xDA, 0x6B, 0x3B, 0x42, 0xD6, 0xC8, 0x74, 0xEB, 0xD7, 0x57, 0x6C, 0x33, 0xAD, 0xC7, 0x56, 0x95, 0x7B, 0x2C, 0x1C, 0xBB, 0xE6, 0x71, 0x76, 0x63, 0xD8, 0xE8, 0xD4, 0x92, 0x0D, 0x79, 0x02, 0x83, 0xC5, 0x38, 0x58, 0x62, 0xCD, 0xB4, 0x0C, 0xE4, 0xCC, 0x48, 0x0A, 0x90, 0x2B, 0x60, 0xFC, 0x4A, 0xA5, 0x3C, 0x1B, 0x6D, 0x55, 0xA6, 0xF1, 0xD2, 0x44, 0xF8, 0x7E, 0x21, 0xC0, 0x4C, 0xAE, 0xA2, 0x14, 0xF6, 0x51, 0x10, 0x84, 0x0B, 0xCA, 0x03, 0x27, 0x4B, 0x6A, 0x9F, 0x06, 0x77, 0xB9, 0x89, 0x34, 0xB5, 0x66, 0x4D, 0xF3, 0xE0, 0x75, 0x69, 0x8B, 0x47, 0xF4, 0x70, 0x24};

// 逆S盒
DECL_STATIC_CONSTEXPR uint8 INV_SBOX[256] = {0xA1, 0x8E, 0xC1, 0xEA, 0x10, 0x7D, 0xEF, 0x5E, 0x11, 0x0E, 0xCD, 0xE8, 0xC9, 0xBF, 0x04, 0x06, 0xE6, 0x59, 0x12, 0x9A, 0xE3, 0x63, 0x2F, 0x56, 0x4B, 0x4C, 0x2B, 0xD5, 0xB5, 0x78, 0x2D, 0x1A, 0x71, 0xDE, 0x3C, 0x9C, 0xFF, 0x41, 0x64, 0xEB, 0x79, 0x6F, 0x8C, 0xCF, 0xB4, 0x1F, 0x3E, 0x9D, 0x6E, 0x0D, 0x6D, 0xAE, 0xF3, 0x5F, 0x96, 0x95, 0xC4, 0x6B, 0x5C, 0xA5, 0xD4, 0x60, 0xA2, 0x01, 0x4A, 0x73, 0xA6, 0x1D, 0xDB, 0x5A, 0x57, 0xFC, 0xCC, 0x27, 0xD2, 0xEC, 0xE0, 0xF6, 0x25, 0x92, 0x32, 0xE5, 0x33, 0x90, 0x02, 0xD7, 0xB1, 0xAC, 0xC5, 0x76, 0x46, 0x08, 0x1E, 0x3D, 0x37, 0x4F, 0xD0, 0x8D, 0xC6, 0xBA, 0x31, 0x7E, 0xF5, 0x13, 0x19, 0xFA, 0xED, 0xA4, 0xAD, 0xD6, 0x30, 0x2E, 0xFE, 0xB8, 0x82, 0x51, 0xA9, 0xF9, 0xB9, 0xF0, 0x61, 0xC0, 0x7F, 0xB3, 0x16, 0x07, 0xDD, 0x98, 0x49, 0x03, 0x5D, 0xC2, 0xE7, 0x80, 0x5B, 0x26, 0x8A, 0xF2, 0x43, 0xFB, 0x38, 0x65, 0x42, 0x9F, 0xCE, 0x48, 0xBE, 0x7B, 0x0A, 0xB2, 0x81, 0x14, 0x55, 0x2A, 0x35, 0x88, 0x22, 0x75, 0x62, 0xEE, 0x93, 0x6A, 0xE2, 0x2C, 0x84, 0xD3, 0xD8, 0x17, 0x8F, 0x86, 0x50, 0x23, 0x83, 0xAF, 0xE1, 0x18, 0x45, 0x4E, 0x9E, 0x74, 0xC8, 0xF4, 0x7C, 0x58, 0x89, 0xF1, 0x69, 0xB6, 0x36, 0x1C, 0x53, 0x15, 0xDF, 0xA0, 0x3A, 0x87, 0x97, 0xC3, 0x72, 0xB0, 0xA8, 0x0F, 0xE9, 0x28, 0xCB, 0xC7, 0x00, 0x09, 0x85, 0x66, 0xDA, 0x0B, 0xBD, 0x68, 0xA7, 0xAB, 0xBB, 0x34, 0xA3, 0x20, 0x39, 0x54, 0x94, 0x70, 0xF8, 0x21, 0x9B, 0x6C, 0xCA, 0x44, 0xB7, 0x1B, 0xBC, 0x47, 0x3F, 0xAA, 0x29, 0x77, 0x91, 0x4D, 0x0C, 0xD9, 0x67, 0xF7, 0xFD, 0x7A, 0xE4, 0x05, 0xDC, 0x99, 0x3B, 0x24, 0xD1, 0x52, 0x40, 0x8B};
// 逆S盒计算
// template <unsigned char InvSBoxIdx, unsigned char SBoxIdx = 0>
// constexpr static unsigned char CalculateInvSBoxValue()
// {
//     if constexpr (XBOX[SBoxIdx] == InvSBoxIdx)
//     {
//         return SBoxIdx;
//     }
//     else
//     {
//         return CalculateInvSBoxValue<InvSBoxIdx, SBoxIdx + 1>();
//     }
// }
//
// template <unsigned char... I>
// constexpr static auto CalculateInvSBoxImpl(std::index_sequence<I...>)
// {
//     constexpr unsigned char box[255]{CalculateInvSBoxValue<I>()...};
//     return box;
// }
//
// constexpr static auto CalculateInvSBox()
// {
//     return CalculateInvSBoxImpl(std::make_index_sequence<255>{});
// }
//
// constexpr static uint8 INV_SBOX[256] = CalculateInvSBox();  // 理论上可以再编译期完成计算，但编译器内部报错
void AESCore::Encrypt(uint8* data, size_t size) DECL_NOEXCEPT
{
    size_t blockCount = size / AES_BLOCK_SIZE;
    for (size_t i = 0; i < blockCount - 1; i++)
    {
        EncryptImpl(data);
        data += AES_BLOCK_SIZE;
    }

    size_t restSize = size % AES_BLOCK_SIZE;
    if (restSize == 0)
    {
        EncryptImpl(data);
    }
    else
    {
        EncryptImpl(data + AES_BLOCK_SIZE - restSize);
        EncryptImpl(data);
    }
}
void AESCore::Decrypt(uint8* data, size_t size) DECL_NOEXCEPT
{
    size_t blockCount = size / AES_BLOCK_SIZE;
    for (size_t i = 0; i < blockCount - 1; i++)
    {
        DecryptImpl(data);
        data += AES_BLOCK_SIZE;
    }

    size_t restSize = size % AES_BLOCK_SIZE;
    if (restSize == 0)
    {
        DecryptImpl(data);
    }
    else
    {
        DecryptImpl(data + AES_BLOCK_SIZE - restSize);
        DecryptImpl(data);
    }
}
// 秘钥扩展
void AESCore::KeyExpansion(uint8 key[32]) DECL_NOEXCEPT
{
    uint8* keyExp = m_aesContext.key_exp;
    ::memset(keyExp, 0, AES_KEY_EXP_SIZE);
    // 用于行列操作的临时变量
    uint8 tempa[4]{0};
    // 初始化扩展秘钥
    // 第一个key的扩展秘钥为它自己本身 NK 列
    // k1  k5  k9   k13  k17  k21  k25  k29 ...
    // k2  k6  k10  k14  k18  k22  k26  k30 ...
    // k3  k7  k11  k15  k19  k23  k27  k31 ...
    // k4  k8  k12  k16  k20  k24  k28  k32 ...
    for (int i = 0; i < AES_KEY_LEN; i++)
    {
        keyExp[i] = key[i];
    }

    // 其他扩展秘钥的计算, 从第NK + 1列开始，共NB * (NR + 1)列,
    // NB * (NR + 1) = 组成一个状态的列数 * 轮数
    for (int i = NK; i < NB * (NR + 1); i++)
    {
        tempa[0] = keyExp[(i - 1) * 4 + 0];
        tempa[1] = keyExp[(i - 1) * 4 + 1];
        tempa[2] = keyExp[(i - 1) * 4 + 2];
        tempa[3] = keyExp[(i - 1) * 4 + 3];

        // 将这一列的元素进行循环左移一个字节
        if (i % NK == 0)
        {
            const uint8 tmp = tempa[0];
            tempa[0]        = tempa[1];
            tempa[1]        = tempa[2];
            tempa[2]        = tempa[3];
            tempa[3]        = tmp;

            // 将这一列的元素进行 S盒替换
            tempa[0] = SBOX[tempa[0]];
            tempa[1] = SBOX[tempa[1]];
            tempa[2] = SBOX[tempa[2]];
            tempa[3] = SBOX[tempa[3]];

            tempa[0] = tempa[0] ^ RCON[i / NK];
        }
        else if (i % NK == 4)
        {
            // 将这一列的元素进行 S盒替换
            tempa[0] = SBOX[tempa[0]];
            tempa[1] = SBOX[tempa[1]];
            tempa[2] = SBOX[tempa[2]];
            tempa[3] = SBOX[tempa[3]];
        }

        // 子密钥的计算
        // 对每一列的元素进行 XOR 运算
        // k1  k5  k9   k13  k17  k21  k25  k29  k33  k37...
        // k2  k6  k10  k14  k18  k22  k26  k30  k34  k38...
        // k3  k7  k11  k15  k19  k23  k27  k31  k35  k39...
        // k4  k8  k12  k16  k20  k24  k28  k32  k36  k40...
        // k33 = k29 XOR k1  k37 = k33 XOR k5
        // k34 = k30 XOR k2  k38 = k34 XOR k6
        // k35 = k31 XOR k3  k39 = k35 XOR k7
        // k36 = k32 XOR k4  k40 = k36 XOR k8
        // 以此类推

        keyExp[i * 4 + 0] = keyExp[(i - NK) * 4 + 0] ^ tempa[0];
        keyExp[i * 4 + 1] = keyExp[(i - NK) * 4 + 1] ^ tempa[1];
        keyExp[i * 4 + 2] = keyExp[(i - NK) * 4 + 2] ^ tempa[2];
        keyExp[i * 4 + 3] = keyExp[(i - NK) * 4 + 3] ^ tempa[3];
    }
}
// 加密一段block 长度16
void AESCore::EncryptImpl(uint8* block) DECL_NOEXCEPT
{
    state_t* state = (state_t*)block;

    // 开始前先进行0轮加密
    AddRoundKey(0, state);
    // 开始进行1到NR-1轮加密
    for (int round = 1;; ++round)
    {
        SubBytes(state);
        ShiftRows(state);
        if (round == NR) break;
        MixColumns(state);
        AddRoundKey(round, state);
    }
    // 开始NR轮加密
    AddRoundKey(NR, state);
}
// 解密一段block 长度16
void AESCore::DecryptImpl(uint8* block) DECL_NOEXCEPT
{
    state_t* state = (state_t*)block;
    // 开始前先进行NR轮的解密
    AddRoundKey(NR, state);

    // 开始进行NR - 1轮到1轮的解密
    for (int round = NR - 1;; --round)
    {
        InvShiftRows(state);
        InvSubBytes(state);
        AddRoundKey(round, state);
        if (round == 0) break;
        InvMixColumns(state);
    }
}
// 秘钥加法
// round: 加密轮数
void AESCore::AddRoundKey(uint8 round, state_t* state) DECL_NOEXCEPT
{
    uint8 v1 = round << 4;
    (*state)[0][0] ^= m_aesContext.key_exp[v1 + 0 + 0];
    (*state)[0][1] ^= m_aesContext.key_exp[v1 + 0 + 1];
    (*state)[0][2] ^= m_aesContext.key_exp[v1 + 0 + 2];
    (*state)[0][3] ^= m_aesContext.key_exp[v1 + 0 + 3];

    (*state)[1][0] ^= m_aesContext.key_exp[v1 + 4 + 0];
    (*state)[1][1] ^= m_aesContext.key_exp[v1 + 4 + 1];
    (*state)[1][2] ^= m_aesContext.key_exp[v1 + 4 + 2];
    (*state)[1][3] ^= m_aesContext.key_exp[v1 + 4 + 3];

    (*state)[2][0] ^= m_aesContext.key_exp[v1 + 8 + 0];
    (*state)[2][1] ^= m_aesContext.key_exp[v1 + 8 + 1];
    (*state)[2][2] ^= m_aesContext.key_exp[v1 + 8 + 2];
    (*state)[2][3] ^= m_aesContext.key_exp[v1 + 8 + 3];

    (*state)[3][0] ^= m_aesContext.key_exp[v1 + 12 + 0];
    (*state)[3][1] ^= m_aesContext.key_exp[v1 + 12 + 1];
    (*state)[3][2] ^= m_aesContext.key_exp[v1 + 12 + 2];
    (*state)[3][3] ^= m_aesContext.key_exp[v1 + 12 + 3];
}
// S盒字节代换
void AESCore::SubBytes(state_t* state) DECL_NOEXCEPT
{
    (*state)[0][0] = SBOX[(*state)[0][0]];
    (*state)[0][1] = SBOX[(*state)[0][1]];
    (*state)[0][2] = SBOX[(*state)[0][2]];
    (*state)[0][3] = SBOX[(*state)[0][3]];

    (*state)[1][0] = SBOX[(*state)[1][0]];
    (*state)[1][1] = SBOX[(*state)[1][1]];
    (*state)[1][2] = SBOX[(*state)[1][2]];
    (*state)[1][3] = SBOX[(*state)[1][3]];

    (*state)[2][0] = SBOX[(*state)[2][0]];
    (*state)[2][1] = SBOX[(*state)[2][1]];
    (*state)[2][2] = SBOX[(*state)[2][2]];
    (*state)[2][3] = SBOX[(*state)[2][3]];

    (*state)[3][0] = SBOX[(*state)[3][0]];
    (*state)[3][1] = SBOX[(*state)[3][1]];
    (*state)[3][2] = SBOX[(*state)[3][2]];
    (*state)[3][3] = SBOX[(*state)[3][3]];
}
// 逆S盒字节代换
void AESCore::InvSubBytes(state_t* state) DECL_NOEXCEPT
{
    (*state)[0][0] = INV_SBOX[(*state)[0][0]];
    (*state)[0][1] = INV_SBOX[(*state)[0][1]];
    (*state)[0][2] = INV_SBOX[(*state)[0][2]];
    (*state)[0][3] = INV_SBOX[(*state)[0][3]];

    (*state)[1][0] = INV_SBOX[(*state)[1][0]];
    (*state)[1][1] = INV_SBOX[(*state)[1][1]];
    (*state)[1][2] = INV_SBOX[(*state)[1][2]];
    (*state)[1][3] = INV_SBOX[(*state)[1][3]];

    (*state)[2][0] = INV_SBOX[(*state)[2][0]];
    (*state)[2][1] = INV_SBOX[(*state)[2][1]];
    (*state)[2][2] = INV_SBOX[(*state)[2][2]];
    (*state)[2][3] = INV_SBOX[(*state)[2][3]];

    (*state)[3][0] = INV_SBOX[(*state)[3][0]];
    (*state)[3][1] = INV_SBOX[(*state)[3][1]];
    (*state)[3][2] = INV_SBOX[(*state)[3][2]];
    (*state)[3][3] = INV_SBOX[(*state)[3][3]];
}
// 行位移
void AESCore::ShiftRows(state_t* state) DECL_NOEXCEPT
{
    // 0  4  8  12      0  4  8  12
    // 1  5  9  13  =>  5  9  13 1
    // 2  6  10 14      10 14 2  6
    // 3  7  11 15      15 3  7  11
    uint8 temp;
    // 第一行不变
    // 第二行左移一位
    temp           = (*state)[0][1];
    (*state)[0][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[3][1];
    (*state)[3][1] = temp;
    // 第三行左移两位
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp           = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;
    // 第四行左移三位
    temp           = (*state)[0][3];
    (*state)[0][3] = (*state)[3][3];
    (*state)[3][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[1][3];
    (*state)[1][3] = temp;
}
// 逆行位移
void AESCore::InvShiftRows(state_t* state) DECL_NOEXCEPT
{
    // 0  4  8  12      0  4  8  12
    // 1  5  9  13  =>  13 1  5  9
    // 2  6  10 14      10 14 2  6
    // 3  7  11 15      7  11 15 3
    uint8 temp;
    // 第一行不变
    // 第二行右移一位
    temp           = (*state)[3][1];
    (*state)[3][1] = (*state)[2][1];
    (*state)[2][1] = (*state)[1][1];
    (*state)[1][1] = (*state)[0][1];
    (*state)[0][1] = temp;
    // 第三行右移两位
    temp           = (*state)[0][2];
    (*state)[0][2] = (*state)[2][2];
    (*state)[2][2] = temp;
    temp           = (*state)[1][2];
    (*state)[1][2] = (*state)[3][2];
    (*state)[3][2] = temp;
    // 第四行右移三位
    temp           = (*state)[0][3];
    (*state)[0][3] = (*state)[1][3];
    (*state)[1][3] = (*state)[2][3];
    (*state)[2][3] = (*state)[3][3];
    (*state)[3][3] = temp;
}
// 列混淆
void AESCore::MixColumns(state_t* state) DECL_NOEXCEPT
{
    uint8 tmp, t1, t2, t3, t4;

    tmp = (*state)[0][0] ^ (*state)[0][1] ^ (*state)[0][2] ^ (*state)[0][3];
    t1  = XTIME[(*state)[0][0] ^ (*state)[0][1]];
    t2  = XTIME[(*state)[0][1] ^ (*state)[0][2]];
    t3  = XTIME[(*state)[0][2] ^ (*state)[0][3]];
    t4  = XTIME[(*state)[0][3] ^ (*state)[0][0]];
    (*state)[0][0] ^= t1 ^ tmp;
    (*state)[0][1] ^= t2 ^ tmp;
    (*state)[0][2] ^= t3 ^ tmp;
    (*state)[0][3] ^= t4 ^ tmp;

    tmp = (*state)[1][0] ^ (*state)[1][1] ^ (*state)[1][2] ^ (*state)[1][3];
    t1  = XTIME[(*state)[1][0] ^ (*state)[1][1]];
    t2  = XTIME[(*state)[1][1] ^ (*state)[1][2]];
    t3  = XTIME[(*state)[1][2] ^ (*state)[1][3]];
    t4  = XTIME[(*state)[1][3] ^ (*state)[1][0]];
    (*state)[1][0] ^= t1 ^ tmp;
    (*state)[1][1] ^= t2 ^ tmp;
    (*state)[1][2] ^= t3 ^ tmp;
    (*state)[1][3] ^= t4 ^ tmp;

    tmp = (*state)[2][0] ^ (*state)[2][1] ^ (*state)[2][2] ^ (*state)[2][3];
    t1  = XTIME[(*state)[2][0] ^ (*state)[2][1]];
    t2  = XTIME[(*state)[2][1] ^ (*state)[2][2]];
    t3  = XTIME[(*state)[2][2] ^ (*state)[2][3]];
    t4  = XTIME[(*state)[2][3] ^ (*state)[2][0]];
    (*state)[2][0] ^= t1 ^ tmp;
    (*state)[2][1] ^= t2 ^ tmp;
    (*state)[2][2] ^= t3 ^ tmp;
    (*state)[2][3] ^= t4 ^ tmp;

    tmp = (*state)[3][0] ^ (*state)[3][1] ^ (*state)[3][2] ^ (*state)[3][3];
    t1  = XTIME[(*state)[3][0] ^ (*state)[3][1]];
    t2  = XTIME[(*state)[3][1] ^ (*state)[3][2]];
    t3  = XTIME[(*state)[3][2] ^ (*state)[3][3]];
    t4  = XTIME[(*state)[3][3] ^ (*state)[3][0]];
    (*state)[3][0] ^= t1 ^ tmp;
    (*state)[3][1] ^= t2 ^ tmp;
    (*state)[3][2] ^= t3 ^ tmp;
    (*state)[3][3] ^= t4 ^ tmp;
}
// 逆列混淆
void AESCore::InvMixColumns(state_t* state) DECL_NOEXCEPT
{
    uint8 s1, s2, s3, s4;
    s1             = (*state)[0][0];
    s2             = (*state)[0][1];
    s3             = (*state)[0][2];
    s4             = (*state)[0][3];
    (*state)[0][0] = MUL_E[s1] ^ MUL_B[s2] ^ MUL_D[s3] ^ MUL_9[s4];
    (*state)[0][1] = MUL_9[s1] ^ MUL_E[s2] ^ MUL_B[s3] ^ MUL_D[s4];
    (*state)[0][2] = MUL_D[s1] ^ MUL_9[s2] ^ MUL_E[s3] ^ MUL_B[s4];
    (*state)[0][3] = MUL_B[s1] ^ MUL_D[s2] ^ MUL_9[s3] ^ MUL_E[s4];
    s1             = (*state)[1][0];
    s2             = (*state)[1][1];
    s3             = (*state)[1][2];
    s4             = (*state)[1][3];
    (*state)[1][0] = MUL_E[s1] ^ MUL_B[s2] ^ MUL_D[s3] ^ MUL_9[s4];
    (*state)[1][1] = MUL_9[s1] ^ MUL_E[s2] ^ MUL_B[s3] ^ MUL_D[s4];
    (*state)[1][2] = MUL_D[s1] ^ MUL_9[s2] ^ MUL_E[s3] ^ MUL_B[s4];
    (*state)[1][3] = MUL_B[s1] ^ MUL_D[s2] ^ MUL_9[s3] ^ MUL_E[s4];
    s1             = (*state)[2][0];
    s2             = (*state)[2][1];
    s3             = (*state)[2][2];
    s4             = (*state)[2][3];
    (*state)[2][0] = MUL_E[s1] ^ MUL_B[s2] ^ MUL_D[s3] ^ MUL_9[s4];
    (*state)[2][1] = MUL_9[s1] ^ MUL_E[s2] ^ MUL_B[s3] ^ MUL_D[s4];
    (*state)[2][2] = MUL_D[s1] ^ MUL_9[s2] ^ MUL_E[s3] ^ MUL_B[s4];
    (*state)[2][3] = MUL_B[s1] ^ MUL_D[s2] ^ MUL_9[s3] ^ MUL_E[s4];

    s1             = (*state)[3][0];
    s2             = (*state)[3][1];
    s3             = (*state)[3][2];
    s4             = (*state)[3][3];
    (*state)[3][0] = MUL_E[s1] ^ MUL_B[s2] ^ MUL_D[s3] ^ MUL_9[s4];
    (*state)[3][1] = MUL_9[s1] ^ MUL_E[s2] ^ MUL_B[s3] ^ MUL_D[s4];
    (*state)[3][2] = MUL_D[s1] ^ MUL_9[s2] ^ MUL_E[s3] ^ MUL_B[s4];
    (*state)[3][3] = MUL_B[s1] ^ MUL_D[s2] ^ MUL_9[s3] ^ MUL_E[s4];
}
}}} // namespace screw::algo::AES

